//
//  Mocks.generated.swift
//  Interfaces
//
//  Generated by Mockingbird v0.20.0.
//  DO NOT EDIT
//

@testable import Interfaces
@testable import Mockingbird
import Combine
import CombineSchedulers
import DomainModels
import Foundation
import Swift
import Swinject

private let mkbGenericStaticMockContext = Mockingbird.GenericStaticMockContext()

// MARK: - Mocked AppSchedulerProviding
public final class AppSchedulerProvidingMock: Interfaces.AppSchedulerProviding, Mockingbird.Mock {
  typealias MockingbirdSupertype = Interfaces.AppSchedulerProviding
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Interfaces"])

  // MARK: Mocked mainScheduler
  public var `mainScheduler`: AnySchedulerOf<DispatchQueue> {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "mainScheduler.getter", setterSelectorName: "mainScheduler.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((AnySchedulerOf<DispatchQueue>).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> AnySchedulerOf<DispatchQueue> { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as AnySchedulerOf<DispatchQueue> }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: AnySchedulerOf<DispatchQueue> = mkbObject.`mainScheduler`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (AnySchedulerOf<DispatchQueue>).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getMainScheduler() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AnySchedulerOf<DispatchQueue>, AnySchedulerOf<DispatchQueue>> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AnySchedulerOf<DispatchQueue>, AnySchedulerOf<DispatchQueue>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "mainScheduler.getter", setterSelectorName: "mainScheduler.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((AnySchedulerOf<DispatchQueue>).self)))
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    AppSchedulerProvidingMock.mockingbirdContext.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `AppSchedulerProviding`.
public func mock(_ type: Interfaces.AppSchedulerProviding.Protocol, file: StaticString = #file, line: UInt = #line) -> AppSchedulerProvidingMock {
  return AppSchedulerProvidingMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked MockAppSchedulerProviding
public final class MockAppSchedulerProvidingMock: Interfaces.MockAppSchedulerProviding, Mockingbird.Mock {
  typealias MockingbirdSupertype = Interfaces.MockAppSchedulerProviding
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Interfaces"])

  // MARK: Mocked mainScheduler
  override public var `mainScheduler`: AnySchedulerOf<DispatchQueue> {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "mainScheduler.getter", setterSelectorName: "mainScheduler.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((AnySchedulerOf<DispatchQueue>).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> AnySchedulerOf<DispatchQueue> { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as AnySchedulerOf<DispatchQueue> }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`mainScheduler`
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: AnySchedulerOf<DispatchQueue> = mkbObject.`mainScheduler`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (AnySchedulerOf<DispatchQueue>).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getMainScheduler() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AnySchedulerOf<DispatchQueue>, AnySchedulerOf<DispatchQueue>> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AnySchedulerOf<DispatchQueue>, AnySchedulerOf<DispatchQueue>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "mainScheduler.getter", setterSelectorName: "mainScheduler.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((AnySchedulerOf<DispatchQueue>).self)))
  }

  // MARK: Mocked testScheduler
  override public var `testScheduler`: TestSchedulerOf<DispatchQueue> {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "testScheduler.getter", setterSelectorName: "testScheduler.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((TestSchedulerOf<DispatchQueue>).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> TestSchedulerOf<DispatchQueue> { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as TestSchedulerOf<DispatchQueue> }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`testScheduler`
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: TestSchedulerOf<DispatchQueue> = mkbObject.`testScheduler`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (TestSchedulerOf<DispatchQueue>).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "testScheduler.setter", setterSelectorName: "testScheduler.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (TestSchedulerOf<DispatchQueue>) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`testScheduler` = newValue
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`testScheduler` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getTestScheduler() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> TestSchedulerOf<DispatchQueue>, TestSchedulerOf<DispatchQueue>> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> TestSchedulerOf<DispatchQueue>, TestSchedulerOf<DispatchQueue>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "testScheduler.getter", setterSelectorName: "testScheduler.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((TestSchedulerOf<DispatchQueue>).self)))
  }

  public func setTestScheduler(_ newValue: @autoclosure () -> TestSchedulerOf<DispatchQueue>) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (TestSchedulerOf<DispatchQueue>) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (TestSchedulerOf<DispatchQueue>) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "testScheduler.setter", setterSelectorName: "testScheduler.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  // MARK: Mocked useTestMainScheduler
  override public var `useTestMainScheduler`: Bool {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "useTestMainScheduler.getter", setterSelectorName: "useTestMainScheduler.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((Bool).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> Bool { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Bool }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`useTestMainScheduler`
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Bool = mkbObject.`useTestMainScheduler`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Bool).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "useTestMainScheduler.setter", setterSelectorName: "useTestMainScheduler.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (Bool) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`useTestMainScheduler` = newValue
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`useTestMainScheduler` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getUseTestMainScheduler() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> Bool, Bool> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> Bool, Bool>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "useTestMainScheduler.getter", setterSelectorName: "useTestMainScheduler.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((Bool).self)))
  }

  public func setUseTestMainScheduler(_ newValue: @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (Bool) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (Bool) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "useTestMainScheduler.setter", setterSelectorName: "useTestMainScheduler.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    self.mockingbirdContext.sourceLocation = sourceLocation
    MockAppSchedulerProvidingMock.mockingbirdContext.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `MockAppSchedulerProviding`.
public func mock(_ type: Interfaces.MockAppSchedulerProviding.Type, file: StaticString = #file, line: UInt = #line) -> MockAppSchedulerProvidingMock {
  return MockAppSchedulerProvidingMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked TravelAdvisoryApiImplementing
public final class TravelAdvisoryApiImplementingMock: Interfaces.TravelAdvisoryApiImplementing, Mockingbird.Mock {
  typealias MockingbirdSupertype = Interfaces.TravelAdvisoryApiImplementing
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Interfaces"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    TravelAdvisoryApiImplementingMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `getCountryDetails`(`regionCode`: String)
  public func `getCountryDetails`(`regionCode`: String) -> AnyPublisher<Interfaces.CountryDetailsDTO, Interfaces.TravelAdvisoryApiError> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`getCountryDetails`(`regionCode`: String) -> AnyPublisher<Interfaces.CountryDetailsDTO, Interfaces.TravelAdvisoryApiError>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`regionCode`)], returnType: Swift.ObjectIdentifier((AnyPublisher<Interfaces.CountryDetailsDTO, Interfaces.TravelAdvisoryApiError>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (String) -> AnyPublisher<Interfaces.CountryDetailsDTO, Interfaces.TravelAdvisoryApiError> { return mkbImpl(`regionCode`) }
      if let mkbImpl = mkbImpl as? () -> AnyPublisher<Interfaces.CountryDetailsDTO, Interfaces.TravelAdvisoryApiError> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: AnyPublisher<Interfaces.CountryDetailsDTO, Interfaces.TravelAdvisoryApiError> = mkbObject.`getCountryDetails`(regionCode: `regionCode`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (AnyPublisher<Interfaces.CountryDetailsDTO, Interfaces.TravelAdvisoryApiError>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `getCountryDetails`(`regionCode`: @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> AnyPublisher<Interfaces.CountryDetailsDTO, Interfaces.TravelAdvisoryApiError>, AnyPublisher<Interfaces.CountryDetailsDTO, Interfaces.TravelAdvisoryApiError>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> AnyPublisher<Interfaces.CountryDetailsDTO, Interfaces.TravelAdvisoryApiError>, AnyPublisher<Interfaces.CountryDetailsDTO, Interfaces.TravelAdvisoryApiError>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`getCountryDetails`(`regionCode`: String) -> AnyPublisher<Interfaces.CountryDetailsDTO, Interfaces.TravelAdvisoryApiError>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`regionCode`)], returnType: Swift.ObjectIdentifier((AnyPublisher<Interfaces.CountryDetailsDTO, Interfaces.TravelAdvisoryApiError>).self)))
  }

  // MARK: Mocked `getCountryList`()
  public func `getCountryList`() -> AnyPublisher<Interfaces.CountryListDTO, Interfaces.TravelAdvisoryApiError> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`getCountryList`() -> AnyPublisher<Interfaces.CountryListDTO, Interfaces.TravelAdvisoryApiError>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((AnyPublisher<Interfaces.CountryListDTO, Interfaces.TravelAdvisoryApiError>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> AnyPublisher<Interfaces.CountryListDTO, Interfaces.TravelAdvisoryApiError> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: AnyPublisher<Interfaces.CountryListDTO, Interfaces.TravelAdvisoryApiError> = mkbObject.`getCountryList`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (AnyPublisher<Interfaces.CountryListDTO, Interfaces.TravelAdvisoryApiError>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `getCountryList`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> AnyPublisher<Interfaces.CountryListDTO, Interfaces.TravelAdvisoryApiError>, AnyPublisher<Interfaces.CountryListDTO, Interfaces.TravelAdvisoryApiError>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> AnyPublisher<Interfaces.CountryListDTO, Interfaces.TravelAdvisoryApiError>, AnyPublisher<Interfaces.CountryListDTO, Interfaces.TravelAdvisoryApiError>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`getCountryList`() -> AnyPublisher<Interfaces.CountryListDTO, Interfaces.TravelAdvisoryApiError>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((AnyPublisher<Interfaces.CountryListDTO, Interfaces.TravelAdvisoryApiError>).self)))
  }

  // MARK: Mocked `getServerStatus`()
  public func `getServerStatus`() -> AnyPublisher<Interfaces.ServerStatusDTO, Interfaces.TravelAdvisoryApiError> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`getServerStatus`() -> AnyPublisher<Interfaces.ServerStatusDTO, Interfaces.TravelAdvisoryApiError>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((AnyPublisher<Interfaces.ServerStatusDTO, Interfaces.TravelAdvisoryApiError>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> AnyPublisher<Interfaces.ServerStatusDTO, Interfaces.TravelAdvisoryApiError> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: AnyPublisher<Interfaces.ServerStatusDTO, Interfaces.TravelAdvisoryApiError> = mkbObject.`getServerStatus`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (AnyPublisher<Interfaces.ServerStatusDTO, Interfaces.TravelAdvisoryApiError>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `getServerStatus`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> AnyPublisher<Interfaces.ServerStatusDTO, Interfaces.TravelAdvisoryApiError>, AnyPublisher<Interfaces.ServerStatusDTO, Interfaces.TravelAdvisoryApiError>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> AnyPublisher<Interfaces.ServerStatusDTO, Interfaces.TravelAdvisoryApiError>, AnyPublisher<Interfaces.ServerStatusDTO, Interfaces.TravelAdvisoryApiError>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`getServerStatus`() -> AnyPublisher<Interfaces.ServerStatusDTO, Interfaces.TravelAdvisoryApiError>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((AnyPublisher<Interfaces.ServerStatusDTO, Interfaces.TravelAdvisoryApiError>).self)))
  }

  // MARK: Mocked `getForbiddenApi`()
  public func `getForbiddenApi`() -> AnyPublisher<Void, Interfaces.TravelAdvisoryApiError> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`getForbiddenApi`() -> AnyPublisher<Void, Interfaces.TravelAdvisoryApiError>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((AnyPublisher<Void, Interfaces.TravelAdvisoryApiError>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> AnyPublisher<Void, Interfaces.TravelAdvisoryApiError> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: AnyPublisher<Void, Interfaces.TravelAdvisoryApiError> = mkbObject.`getForbiddenApi`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (AnyPublisher<Void, Interfaces.TravelAdvisoryApiError>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `getForbiddenApi`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> AnyPublisher<Void, Interfaces.TravelAdvisoryApiError>, AnyPublisher<Void, Interfaces.TravelAdvisoryApiError>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> AnyPublisher<Void, Interfaces.TravelAdvisoryApiError>, AnyPublisher<Void, Interfaces.TravelAdvisoryApiError>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`getForbiddenApi`() -> AnyPublisher<Void, Interfaces.TravelAdvisoryApiError>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((AnyPublisher<Void, Interfaces.TravelAdvisoryApiError>).self)))
  }
}

/// Returns a concrete mock of `TravelAdvisoryApiImplementing`.
public func mock(_ type: Interfaces.TravelAdvisoryApiImplementing.Protocol, file: StaticString = #file, line: UInt = #line) -> TravelAdvisoryApiImplementingMock {
  return TravelAdvisoryApiImplementingMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}
